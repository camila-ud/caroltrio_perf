def automatic_summary_v2(inputfile,resultpath,
                        plot = True,name_layer = 'conv7',
                        idlayer = 6):
    audiopath = inputfile
    #extract conv7
    
    
    ## extract features and find k and c
    audio,conv = extract(audiopath,idlayer) #conv7
    k = spectral_explore_neighbors(conv)
    c = spectral_explore_cluster(conv,k,version = True)
    ##make clustering
    labels = make_clustering(conv,k,c)

    #get slope (m) and interception (b) for a given layer
    m,b = get_values()[name_layer] 
    t = (np.array(range(0,len(labels))))/m    
    cluster = np.stack([t,labels]).T  #time and labels

    print(cluster.shape)
    #write segments 
    write(audio,labels,name_layer,resultpath)

    to_tsne(conv,labels,resultpath)  #tsne
    print("tsne exported")
    if plot:
        plot_two_axis(audio,labels,name_layer,resultpath) #plot
        print("plot exported")
    np.savez_compressed("{}/features_conv_v2{}.npz".format(resultpath,idlayer+1),
                       feature_vector = conv,idlayer = idlayer,labels = cluster)
    
    del audio,conv,labels,cluster

def spectral_explore_neighbors(features_vector,max_neighbors=30):
    metrics = []
    #Find number neighbors    
    if max_neighbors > features_vector.shape[0]:
        max_neighbors = features_vector.shape[0]//2 
    
    number = range(2,max_neighbors +1)
    for i in tqdm(number): 
        #fix n-cluster = 2, evaluate using calinski and silhouette
        spectral = SpectralClustering(n_clusters=2, 
                                      eigen_solver='arpack',
                                      affinity="nearest_neighbors",
                                      assign_labels="discretize",
                                      random_state=0,n_neighbors=i,n_jobs = -1).fit((features_vector))
        labels = spectral.labels_
        metrics.append([silhouette_score(features_vector, labels,metric='cosine'),  # silhouette : best 1, worst -1 
                        calinski_harabasz_score(features_vector, labels)])   # calinski: the higher the better
       
    df = pd.DataFrame(metrics,index = number, columns = ['silhouette','calinski'])
    df.plot(y=['silhouette','calinski'],subplots=True,sharex=True,figsize=(10,12),fontsize=14,linewidth=2)
        
    ##best_neighbors: The mean of the indices where the first derivative of the metrics is maximum.
    best_neighbors = int(round((df.diff().idxmax().mean())))
    print("Best number of neighbors is {:d}".format(best_neighbors))
    return best_neighbors
